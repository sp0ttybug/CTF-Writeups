from sympy import mod_inverse

# Given values
N = 429121770631378567901343966601594638005200015410084049877005074706242144998835920068635924092327155154777724260920698564074246047428058702591438336354875385912113367812170140583119952718402254809563407665546757040976089024031265008069827573661895233187750822966323913745243562262084682435720233192587715830559

e1 = 386032633976106490452762780248103046765080671002988892055330641519564235852922762822642402279578918838636246752652910094048142722891896247145254930177193887644017516737007121616205743252470102524562046452022844285592502850136557110998891279346966111674327705149116034487327385428052869529026582167188809884767
e2 = 163750396495935852923904966204815324377529736034694345075646930507887571607611362069683718460469444053908143551023118580605176614326477189584938691146244409712347416452049032774643069943984015216081063830861336324570672997063592368707183334828352359237101478758418750499394554746092209859925767816955766723283

C1 = 87502995845613296640748517793461033238581559539831264070261405010457509045073974678421603483424284030953936003665163387882484477968792761078988595610302455403388677294958433069302896533782914177156060718958383452389999702278314396059598387560745347823772156262268912853464875822933280715397288456397500467082
C2 = 136066714893268542026804519389494696977338362492232911025630528665249367078493449633065764703691698428341934584595699819793588312946103371760765032815931350400960037961574476205220355485393336049341594068050222109820636564284034763886026894874140832144968716951111868453836181469982554783322713071884032213425

# Step 1: Verify that gcd(e1, e2) = 1
def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y

gcd, a, b = extended_gcd(e1, e2)
assert gcd == 1, "gcd(e1, e2) is not 1"

# Step 2: Compute the combined ciphertext C using the formula C = (C1^a * C2^b) % N
def mod_exp(base, exp, mod):
    if exp < 0:
        base = mod_inverse(base, mod)
        exp = -exp
    return pow(base, exp, mod)

M = (mod_exp(C1, a, N) * mod_exp(C2, b, N)) % N

# Step 3: Print the decrypted message M
print(M)
# Convert the decrypted message to a readable string if it's in byte format
print(bytes.fromhex(hex(M)[2:]).decode('utf-8'))
# except:
#     print("The decrypted message is not a valid UTF-8 string.")
